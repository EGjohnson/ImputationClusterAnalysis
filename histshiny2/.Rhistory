my.val=2:4
base^my.val
base+my.val
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
base<-2
foreach(my.val = 2:4,
.combine = rbind)  %dopar%
base+my.val
# stop cluster and release resources
stopCluster(my.cluster)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
base<-2
foreach(my.val = 2:4,
.combine = rbind)  %dopar%  base+my.val
# stop cluster and release resources
stopCluster(my.cluster)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
base<-2
foreach(my.val = 2:4, .combine = rbind)  %dopar%  base+my.val
# stop cluster and release resources
stopCluster(my.cluster)
lapply(1:5, function(x) c(x+100,x+200,x+300))
library(parallel)
# Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
# cluster will only be able
b<-100
# create a cluster using 6 of my computer cores FORK in environmental variables
my.cluster <- makeCluster(number_cores,type="FORK")
# use parralel version of lapply (list to list)
my.list<-parLapply(my.cluster, 1:5,function(x) x+b)
#use parallel version of sapply (list to array)
my.vector<-parSapply(my.cluster,1:5,function(x) x+b)
# stop cluster and release resources
stopCluster(my.cluster)
print("my.list")
print(my.list)
print("my.vector")
print(my.vector)
library(foreach)
library(doParallel)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
base<-2
foreach(my.val = 2:4, .combine = rbind)  %dopar%  base+my.val
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
base<-2
foreach(my.val = 2:4, .combine = rbind)  %dopar%  base^my.val
# stop cluster and release resources
stopCluster(my.cluster)
times(3) %do% rnorm(1)
times(3)
foreach(i=1:3) %do%
sqrt(i)
foreach(i=1:3) %do%
sqrt(i)
foreach(i=1:3) %do%
sqrt(i)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
base<-2
foreach(i = 1:4, .combine = c)  %dopar%  base^i
# stop cluster and release resources
stopCluster(my.cluster)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
base<-2
foreach(i = 1:4, .combine = c)  %dopar%  i+i
# stop cluster and release resources
stopCluster(my.cluster)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
base<-2
foreach(i = 1:4, .combine = c)  %dopar%  base+i
# stop cluster and release resources
stopCluster(my.cluster)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
base<-2
foreach(i = 1:4, .combine = list)  %dopar%  base+i
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
foreach(i = 1:4, .combine = c)  %dopar%  i+i
# stop cluster and release resources
stopCluster(my.cluster)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
foreach(i=1:4, j=4:8.combine = c)  %dopar%  i+j
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
foreach(i=1:4, j=4:8,.combine = c)  %dopar%  i+j
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
foreach(i=1:4,j=4:8,.combine = c)  %dopar%  i+j
foreach(i=1:4, j=1:10) %do%
sqrt(i+j)
foreach(i=1:4, j=1:10,.combine=c) %do%
sqrt(i+j)
foreach(i=1:4, j=1:10,.combine=c) %do%
i+j
foreach(i=1:4, j=1:10,.combine=c) %do%
i+j
foreach(i=1:4, j=1:10,.combine=c) %do%
i+j
foreach(i=1:4, j=1:10) %do%
i+j
foreach(i=1:4,j=1:10) %do%
i+j
foreach(i=1:4,j=1:10) %do% i+j
foreach(i=1:4, j=1:10,.combine=c) %do%
i+j
foreach(i=1:4, j=4:8,.combine=c) %do%
i+j
foreach(i=1:4, j=4:8,.combine=c) %do%
i+j
foreach(i=1:4, j=4:8) %do%
i+j
foreach(i=1:4, j=4:8) %do%
i+j
foreach(i=1:4, j=1:4) %do%
i+j
# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
sqrt(i+j)
# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
i+j
# multiple ... arguments
foreach(i=1:4, j=1:10) %do% i+j
# multiple ... arguments
foreach(i=1:4, j=1:4) %do% i+j
# multiple ... arguments
foreach(i=1:4, j=1:4) %do%
i+j
# multiple ... arguments
foreach(i=1:4,j=1:4) %do%
i+j
# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
sqrt(i+j)
# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
c(i+j)
# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
integer(i+j)
# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
c(i+j)
# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
sqrt(i+j)
# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
function(i,j): i+j
# multiple ... arguments
the.funct<- function(i,j){i+j}
foreach(i=1:4, j=1:10) %do% the.funct(i,j)
# multiple ... arguments
the.funct<- function(i,j){i+j}
foreach(i=1:4, j=1:4) %do% the.funct(i,j)
# multiple ... arguments
the.funct<- function(i,j){i+j}
foreach(i=1:4, j=4:8) %do% the.funct(i,j)
foreach(i=1:4, j=4:8,.combine=c) %do% the.funct(i,j)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
foreach(i=1:4,j=4:8,.combine = c)  %dopar%  the.funct(i+j)
my.cluster<-makeCluster(number_cores)
registerDoParallel(my.cluster)
foreach(i=1:4,j=4:8,.combine = c)  %dopar%  the.funct(i,j)
# stop cluster and release resources
stopCluster(my.cluster)
# multiple ... arguments
the.funct<- function(i,j){i+j}
foreach(i=1:20, j=20:40) %do% the.funct(i,j)
# multiple ... arguments
the.funct<- function(i,j){i+j}
foreach(i=1:4, j=4:8) %do% the.funct(i,j)
my.cluster<-makeCluster(number_cores,type="FORK")
registerDoParallel(my.cluster)
foreach(i=1:4,j=4:8,.combine = c)  %dopar%  the.funct(i,j)
# stop cluster and release resources
stopCluster(my.cluster)
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#iterate
foreach(i=1:4,j=4:8,.combine = c)  %dopar%  the.funct(i,j)
# stop cluster and release resources
stopCluster(my.cluster)
lapply(1:5, function(x) c(x+100,x+200,x+300))
library(parallel)
# Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
lapply(1:5, function(x) c(x+100,x+200,x+300))
library(parallel)
# Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
# cluster will only be able
b<-100
# create a cluster using 6 of my computer cores FORK in environmental variables
my.cluster <- makeCluster(number_cores,type="FORK")
# use parralel version of lapply (list to list)
my.list<-parLapply(my.cluster, 1:5,function(x) x+b)
#use parallel version of sapply (list to array)
my.vector<-parSapply(my.cluster,1:5,function(x) x+b)
# stop cluster and release resources
stopCluster(my.cluster)
print("my.list")
print(my.list)
print("my.vector")
print(my.vector)
# multiple ... arguments
the.funct<- function(i,j){i+j}
foreach(i=1:4, j=4:8) %do% the.funct(i,j)
library(foreach)
library(doParallel)
# multiple ... arguments
the.funct<- function(i,j){i+j}
foreach(i=1:4, j=4:8) %do% the.funct(i,j)
foreach(i=1:4, j=4:8,.combine=c) %do% the.funct(i,j)
library(foreach)
library(doParallel)
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
foreach(i=1:4,j=4:8,.combine = c)  %dopar%  the.funct(i,j)
# stop cluster and release resources
stopCluster(my.cluster)
# multiple ... arguments
the.funct<- function(i,j){i+j*k}
foreach(i=1:4, j=4:8,k=9:12) %do% the.funct(i,j)
foreach(i=1:4, j=4:8,k=9:12,.combine=c) %do% the.funct(i,j)
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
foreach(i=1:4,j=4:8,.combine = c)  %dopar%  the.funct(i,j)
# stop cluster and release resources
stopCluster(my.cluster)
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
foreach(i=1:4,j=4:8,k=9:12,.combine = c)  %dopar%  the.funct(i,j)
# stop cluster and release resources
stopCluster(my.cluster)
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
timeit(foreach(i=1:4,j=4:8,k=9:12,.combine = c)  %dopar%  the.funct(i,j))
library(foreach)
library(timeit)
install.packages("Smisc")
library(foreach)
library(Smisc)
library(doParallel)
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
timeit(foreach(i=1:4,j=4:8,k=9:12,.combine = c)  %dopar%  the.funct(i,j))
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
timeIt(foreach(i=1:4,j=4:8,k=9:12,.combine = c)  %dopar%  the.funct(i,j))
# stop cluster and release resources
stopCluster(my.cluster)
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
timeIt(foreach(i=1:4,j=4:8,k=9:12,.combine = c)  %dopar%  the.funct(i,j))
# stop cluster and release resources
stopCluster(my.cluster)
timeIt(foreach(i=1:4, j=4:8,k=9:12,.combine=c) %do% the.funct(i,j))
1;2
1;2
1:2
1:2 *100
timeIt(foreach(i=1:1000*20, j=1:1000*40,k=1:100,.combine=c) %do% the.funct(i,j))
timeIt(foreach(i=1:10000*20, j=1:10000*40,k=1:1000,.combine=c) %do% the.funct(i,j))
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
timeIt(foreach(i=1:10000*20, j=1:10000*40,k=1:1000,.combine = c)  %dopar%  the.funct(i,j))
# stop cluster and release resources
stopCluster(my.cluster)
# multiple ... arguments
the.funct<- function(i,j,k){i+j*k}
foreach(i=1:4, j=4:8,k=9:12) %do% the.funct(i,j)
# multiple ... arguments
the.funct<- function(i,j,k){i+j*k}
foreach(i=1:4, j=4:8,k=9:12) %do% the.funct(i,j,k)
timeIt(foreach(i=1:10000*20, j=1:10000*40,k=1:1000,.combine=c) %do% the.funct(i,j,k))
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
timeIt(foreach(i=1:10000*20, j=1:10000*40,k=1:1000,.combine = c)  %dopar%  the.funct(i,j,k))
# stop cluster and release resources
stopCluster(my.cluster)
timeIt(foreach(i=1:100000*20, j=1:100000*40,k=1:100000,.combine=c) %do% the.funct(i,j,k))
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
#run iteration over clusters
timeIt(foreach(i=1:100000*20, j=1:100000*40,k=1:100000,.combine = c)  %dopar%  the.funct(i,j,k))
# stop cluster and release resources
stopCluster(my.cluster)
cl
lapply(1:5, function(x) c(x+100,x+200,x+300))
library(parallel)
# Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
library(foreach)
library(Smisc)
library(doParallel)
# multiple ... arguments
the.funct<- function(i,j,k){i+j*k}
foreach(i=1:4, j=4:8,k=9:12) %do% the.funct(i,j,k)
timeIt(foreach(i=1:100000*20, j=1:100000*40,k=1:100000,.combine=c) %do% the.funct(i,j,k))
detectCores()
my.cluster <- makeCluster(number_cores,type="FORK")
my.cluster
stopCluster(my.cluster)
my.cluster <- makeCluster(number_cores,type="FORK")
print my.cluster
print(my.cluster)
my.cluster
my.cluster$host
my.cluster$rank
my.cluster <- makeCluster(number_cores,type="FORK")
my.cluster
# stop cluster and release resources
stopCluster(my.cluster)
lapply(1:5, function(x) c(x+100,x+200,x+300))
sapply(1:5, function(x) c(x+100,x+200,x+300))
lapply(1:5, function(x) c(x+100,x+200,x+300))
sapply(1:3, function(x) c(x+100,x+200,x+300))
lapply(1:3, function(x) c(x+100,x+200,x+300))
sapply(1:3, function(x) c(x+100,x+200,x+300))
lapply(1:3, function(x) c(x+100,x+200,x+300))
sapply(1:3, function(x) c(x+100,x+200,x+300))
lapply(1:3, function(x) b+x)
b=100
lapply(1:3, function(x) b+x)
sapply(1:3, function(x) b+x)
b<-100
lapply(1:3, function(x) b+x)
sapply(1:3, function(x) b+x)
# multiple ... arguments
the.funct<- function(i,j,k){sin(i+j*k)}
timeIt(seq.output<-foreach(i=1:4, j=4:8,k=9:12,.combine=c) %do% the.funct(i,j,k))
library(foreach)
library(parallel)
library(Smisc)
library(doParallel)
library(iterators)
# multiple ... arguments
the.funct<- function(i,j,k){sin(i+j*k)}
timeIt(seq.output<-foreach(i=1:4, j=4:8,k=9:12,.combine=c) %do% the.funct(i,j,k))
print(seq.output)
# multiple ... arguments
max.val<-10^4
the.funct<- function(i,j,k){sin(i)+cos(i+pi)}
timeIt(seq.output<-foreach(i=1:max.val,.combine=c) %do% the.funct(i))
print(seq.output)
# multiple ... arguments
max.val<-10^4
the.funct<- function(i,j,k){sin(i)+cos(i+pi)}
timeIt(seq.output<-foreach(i=1:max.val,.combine=c) %do% the.funct(i))
# multiple ... arguments
max.val<-10^4
the.funct<- function(i,j,k){sin(i)+cos(i+pi)+tan(i*i)}
timeIt(seq.output<-foreach(i=1:max.val,.combine=c) %do% the.funct(i))
# multiple ... arguments
max.val<-10^4
the.funct<- function(i,j,k){sin(i)+cos(i+pi*i)+tan(i*i)}
timeIt(seq.output<-foreach(i=1:max.val,.combine=c) %do% the.funct(i))
# multiple ... arguments
max.val<-10^4
the.funct<- function(i,j,k){sin(i)+cos(i+pi*i)+tan(i*i+pi)}
timeIt(seq.output<-foreach(i=1:max.val,.combine=c) %do% the.funct(i))
# multiple ... arguments
max.val<-10^4
the.funct<- function(i,j,k){tan(sin(i)+cos(i+pi*i)+tan(i*i+pi))}
timeIt(seq.output<-foreach(i=1:max.val,.combine=c) %do% the.funct(i))
# multiple ... arguments
max.val<-10^
the.funct<- function(i,j,k){tan(sin(i)+cos(i+pi*i)+tan(i+2*pi))}
# multiple ... arguments
max.val<-10^
the.funct<- function(i,j,k){sin(i)+cos(i+pi*i)+tan(i+2*pi)}
# multiple ... arguments
max.val<-10^
the.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)}
# multiple ... arguments
max.val<-10^5
the.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)}
timeIt(seq.output<-foreach(i=1:max.val,.combine=c) %do% the.funct(i))
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
he.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)}
timeIt(par.output<-foreach(i=1:max.val,.combine=c) %pardo% the.funct(i))
#Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
he.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)}
timeIt(par.output<-foreach(i=1:max.val,.combine=c) %dopar% the.funct(i))
# stop cluster and release resources
stopCluster(my.cluster)
print(par.output[3])
#Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
the.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)}
timeIt(par.output<-foreach(i=1:max.val,.combine=c) %dopar% the.funct(i))
# stop cluster and release resources
stopCluster(my.cluster)
print(par.output[3])
# multiple ... arguments
max.val<-10^4
the.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)}
timeIt(seq.output<-foreach(i=1:max.val,.combine=c) %do% the.funct(i))
#Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
the.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)}
timeIt(par.output<-foreach(i=1:max.val,.combine=c) %dopar% the.funct(i))
# stop cluster and release resources
stopCluster(my.cluster)
print(par.output[3])
# multiple ... arguments
max.val<-10^4
the.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)*[1:5]}
# multiple ... arguments
max.val<-10^4
the.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)*1:5}
timeIt(seq.output<-foreach(i=1:max.val,.combine=c) %do% the.funct(i))
#Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
the.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)}
timeIt(par.output<-foreach(i=1:max.val,.combine=c) %dopar% the.funct(i))
# stop cluster and release resources
stopCluster(my.cluster)
print(par.output[3])
#Calculate the number of cores and substract 2
number_cores <- detectCores() - 2
#set up cluster: only fork on non-windows
my.cluster<-makeCluster(number_cores,type="FORK")
#register mycluster for %dopar%
registerDoParallel(my.cluster)
the.funct<- function(i){sin(i)+cos(i+pi*i)+tan(i+2*pi)*1:5}
timeIt(par.output<-foreach(i=1:max.val,.combine=c) %dopar% the.funct(i))
# stop cluster and release resources
stopCluster(my.cluster)
print(par.output[3])
setwd("~/PetGit/ImputationClusterAnalysis/histshiny2/"
)
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
prop.sale<-readRDS("data/propsale.rds")
prop.sale[,1]
prop.sale[,"PRICE"]
mean(prop.sale[,"PRICE"])
runApp()
runApp()
